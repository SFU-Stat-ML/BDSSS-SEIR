parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r -1], a.f, b.f,
pop.size,
0.02)
parameters.CSMC.AS.repM$gamma[1,r] <- mh.gamma.update$new.gamma
accept.gamma <- c(accept.gamma, mh.gamma.update$indicator)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
T <- length(y)-1
lenXset <- length(regimes)
N <- M*lenXset
# Set up matrices to store particles
SsampleMat.CSMC.AS.repM <- matrix(0, niter, T+1, byrow = TRUE)
EsampleMat.CSMC.AS.repM <- matrix(0, niter, T+1, byrow = TRUE)
IsampleMat.CSMC.AS.repM <- matrix(0, niter, T+1, byrow = TRUE)
RsampleMat.CSMC.AS.repM <- matrix(0, niter, T+1, byrow = TRUE)
XsampleMat.CSMC.AS.repM <- matrix(0, niter, T+1, byrow = TRUE)
parameters.CSMC.AS.repM <- list("alpha"= matrix(0, 1, niter, byrow = TRUE),
"beta" = matrix(0, 1, niter, byrow = TRUE),
"gamma" = matrix(0, 1, niter, byrow = TRUE),
"lambda" = matrix(0, 1, niter, byrow = TRUE),
"kappa" = matrix(0, 1, niter, byrow = TRUE),
"Px" = vector(mode = "list", length = niter),
"f" = matrix(0, lenXset, niter, byrow = TRUE),
"p" = matrix(0, 1, niter, byrow = TRUE))
marginalLogLik.CSMC.AS.repM <- matrix(0, 1, niter, byrow = TRUE)
# Prior distributions for ψ = {α, β, γ, λ, κ, PX , fxt, }
### Hyperparameters setting
m.alpha <- 0.3
sigma.alpha <- 0.05
m.beta <- 0.4
sigma.beta <- 0.05
m.gamma <- 0.2
sigma.gamma <- 0.05
a.lambda <- 2
b.lambda <- 0.001
a.kappa <- 20
b.kappa <- 0.001
a.p <- 0.25
b.p <- 0.25
delta.mat <- matrix(c(1,1,1,1), nrow = lenXset, ncol = lenXset)
a.f <- 0
b.f <- 1
# (1) Initialisation, r=0
# Choose psi arbitrarily, and draw {theta^(b_0:T)_0:T,x^(b_0:T)_0:T} from {Theta_0:T,X_0:T,A_1:T}
r = 1
print(paste('PG-CSMC-AS-repM: iteration ', r))
## Arbitrarily generate psi from prior distributions
### SEIR model parameters: alpha, beta, gamma
(parameters.CSMC.AS.repM$alpha[1,r] <- rtruncnorm(1, a=0, b=Inf, mean = m.alpha, sd = sigma.alpha))
(parameters.CSMC.AS.repM$beta[1,r] <- rtruncnorm(1, a=0, b=Inf, mean = m.beta, sd = sigma.beta))
(parameters.CSMC.AS.repM$gamma[1,r] <- rtruncnorm(1, a=0, b=Inf, mean = m.gamma, sd = sigma.gamma))
### Precision parameters: lambda, kappa
(parameters.CSMC.AS.repM$lambda[1,r] <- rgamma(1, shape = a.lambda, rate = b.lambda))  # mean = a.lambda/b.lambda
(parameters.CSMC.AS.repM$kappa[1,r] <- rgamma(1, shape = a.kappa, rate = b.kappa))
# (parameters.CSMC$kappa[1,r] <- 2000)
### Transition probability matrix: Px
library("gtools")
(parameters.CSMC.AS.repM$Px[[r]] <-  matrix(t(DirichletReg::rdirichlet(lenXset, delta.mat)),
nrow = lenXset,
ncol = lenXset,
byrow = TRUE))
### Transmission Rate modifier: f_{x_t}
(parameters.CSMC.AS.repM$f[,r] <- c(1,
runif(1, min=a.f, max=b.f)))
### Detection Rate: p
(parameters.CSMC.AS.repM$p[1,r] <- runif(1, min=a.p, max=b.p))
# parameters.CSMC$p[1,r] <- 0.2
### Draw {theta^(b_0:T)_0:T,x^(b_0:T)_0:T} from {THETA_0:T,X_0:T,A_1:T} by running one iteration of SMC
ptm <- proc.time()
SMC.results <- SMC(y,
regimes,
N,
parameters.CSMC.AS.repM$Px[[r]],
parameters.CSMC.AS.repM$alpha[1,r],
parameters.CSMC.AS.repM$beta[1,r],
parameters.CSMC.AS.repM$gamma[1,r],
parameters.CSMC.AS.repM$lambda[1,r],
parameters.CSMC.AS.repM$kappa[1,r],
parameters.CSMC.AS.repM$p[1,r],
parameters.CSMC.AS.repM$f[,r],
pop.size)
proc.time() - ptm
marginalLogLik.CSMC.AS.repM[r] <- sum(SMC.results$logLikY)
### Sample the reference trajectory
# Draw L in {1:N}
L <- sample(1:N, 1, prob = SMC.results$normalisedWeights[, T+1])
# Create reference trajectory
RefParticleS <- rep(0, T+1)
RefParticleE <- rep(0, T+1)
RefParticleI <- rep(0, T+1)
RefParticleR <- rep(0, T+1)
RefParticleX <- rep(0, T+1)
# Recover b_0:T
b <- rep(0, T+1)
b[T+1] <- L
RefParticleS[T+1] <- SMC.results$particlesS[b[T+1],T+1]
RefParticleE[T+1] <- SMC.results$particlesE[b[T+1],T+1]
RefParticleI[T+1] <- SMC.results$particlesI[b[T+1],T+1]
RefParticleR[T+1] <- SMC.results$particlesR[b[T+1],T+1]
RefParticleX[T+1] <- SMC.results$particlesX[b[T+1],T+1]
for (t in T:1){
b[t] <- SMC.results$AncestorLineage[b[t+1], t]
RefParticleS[t] <- SMC.results$particlesS[b[t],t]
RefParticleE[t] <- SMC.results$particlesE[b[t],t]
RefParticleI[t] <- SMC.results$particlesI[b[t],t]
RefParticleR[t] <- SMC.results$particlesR[b[t],t]
RefParticleX[t] <- SMC.results$particlesX[b[t],t]
}
SsampleMat.CSMC.AS.repM[r,] <- RefParticleS
EsampleMat.CSMC.AS.repM[r,] <- RefParticleE
IsampleMat.CSMC.AS.repM[r,] <- RefParticleI
RsampleMat.CSMC.AS.repM[r,] <- RefParticleR
XsampleMat.CSMC.AS.repM[r,] <- RefParticleX
# Draw reference I_t and compare it with y_t
plot(1:length(y), y, col="grey")
lines(RefParticleI*parameters.CSMC.AS.repM$p[1,r], col="red")
# Draw reference X_t and compare it with x_t
plot(1:length(x), x, type = "p", col = "grey", pch=20)
lines(1:length(RefParticleX), RefParticleX, type = "l", col = "blue")
# Compute acceptance rate
accept.kappa <- c()
accept.lambda <- c()
accept.alpha <- c()
accept.beta <- c()
accept.gamma <- c()
accept.p <-c()
accept.pi.1 <- c()
accept.pi.2 <- c()
accept.f <- matrix(0, nrow=lenXset, ncol=niter-1)
# (2) For iteration at r = 1, ..., R
ptm <- proc.time()
pb <- txtProgressBar(min = 0, max = niter+1, style = 3) # Show progress bar
while (r < niter){
r = r+1
# i) Run CSMC-AS with replicator M conditional on {theta(b_0:T)_0:T,x(b_0:T)_0:T} to obtain {Θ^1:N_0:T , X^1:N_0:T , A^1:N_1:T }
CSMC.AS.repMresults <- CSMC.AS.repM(y,
regimes,
RefParticleS, RefParticleE, RefParticleI, RefParticleR, RefParticleX,
M,
parameters.CSMC.AS.repM$Px[[r-1]],
parameters.CSMC.AS.repM$alpha[1,r-1],
parameters.CSMC.AS.repM$beta[1,r-1],
parameters.CSMC.AS.repM$gamma[1,r-1],
parameters.CSMC.AS.repM$lambda[1,r-1],
parameters.CSMC.AS.repM$kappa[1,r-1],
parameters.CSMC.AS.repM$p[1,r-1],
parameters.CSMC.AS.repM$f[,r-1],
pop.size)                               # f_{x_t}
# Get marginal likelihood
marginalLogLik.CSMC.AS.repM[r] <- sum(CSMC.AS.repMresults$logLikY)
### ii) Sample the reference trajectory
### Sample the reference trajectory
# Draw L in {1:N}
L <- sample(1:N, 1, prob = CSMC.AS.repMresults$normalisedWeights[, T+1])
# Create reference trajectory
RefParticleS <- rep(0, T+1)
RefParticleE <- rep(0, T+1)
RefParticleI <- rep(0, T+1)
RefParticleR <- rep(0, T+1)
RefParticleX <- rep(0, T+1)
# Recover b_0:T
b <- rep(0, T+1)
b[T+1] <- L
RefParticleS[T+1] <- CSMC.AS.repMresults$particlesS[b[T+1],T+1]
RefParticleE[T+1] <- CSMC.AS.repMresults$particlesE[b[T+1],T+1]
RefParticleI[T+1] <- CSMC.AS.repMresults$particlesI[b[T+1],T+1]
RefParticleR[T+1] <- CSMC.AS.repMresults$particlesR[b[T+1],T+1]
RefParticleX[T+1] <- CSMC.AS.repMresults$particlesX[b[T+1],T+1]
for (t in T:1){
b[t] <- CSMC.AS.repMresults$AncestorLineage[b[t+1], t]
RefParticleS[t] <- CSMC.AS.repMresults$particlesS[b[t],t]
RefParticleE[t] <- CSMC.AS.repMresults$particlesE[b[t],t]
RefParticleI[t] <- CSMC.AS.repMresults$particlesI[b[t],t]
RefParticleR[t] <- CSMC.AS.repMresults$particlesR[b[t],t]
RefParticleX[t] <- CSMC.AS.repMresults$particlesX[b[t],t]
}
SsampleMat.CSMC.AS.repM[r,] <- RefParticleS
EsampleMat.CSMC.AS.repM[r,] <- RefParticleE
IsampleMat.CSMC.AS.repM[r,] <- RefParticleI
RsampleMat.CSMC.AS.repM[r,] <- RefParticleR
XsampleMat.CSMC.AS.repM[r,] <- RefParticleX
# iii) Draw \psi from p(\psi|\theta_(b_{0:T}), x_(b_{0:T}), b_0:T)
# ChangeLocation <- which(RefParticleX==2)
# Latency rate: alpha
mh.alpha.update <- update.alpha(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1,r-1], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1,r-1], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r-1], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r-1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r-1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r-1]], delta.mat,
parameters.CSMC.AS.repM$f[, r-1], a.f, b.f,
pop.size,
0.02)
parameters.CSMC.AS.repM$alpha[1,r] <- mh.alpha.update$new.alpha
accept.alpha <- c(accept.alpha, mh.alpha.update$indicator)
# # Transmission rate: beta
mh.beta.update <- update.beta(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r -1], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r -1], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r -1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r-1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r-1],a.f, b.f,
pop.size,
0.02)
parameters.CSMC.AS.repM$beta[1,r] <- mh.beta.update$new.beta
accept.beta <- c(accept.beta, mh.beta.update$indicator)
# parameters.CSMC.AS.repM$beta[1,r] <- 0.39
# # Recovery rate: gamma
mh.gamma.update<- update.gamma(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r -1], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r -1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r -1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r -1], a.f, b.f,
pop.size,
0.02)
parameters.CSMC.AS.repM$gamma[1,r] <- mh.gamma.update$new.gamma
accept.gamma <- c(accept.gamma, mh.gamma.update$indicator)
# parameters.CSMC.AS.repM$gamma[1,r] <- 0.2
# # # Precision parameter: kappa
mh.kappa.update <- update.kappa(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r -1], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r-1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1],a.f, b.f,
pop.size,
500)
parameters.CSMC.AS.repM$kappa[1,r] <- mh.kappa.update$new.kappa
accept.kappa <- c(accept.kappa, mh.kappa.update$indicator)
# parameters.CSMC.AS.repM$kappa[1,r] <- 20000
# # Precision parameter: lambda
mh.lambda.update <- update.lambda(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r -1], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r -1], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r -1], a.f, b.f,
pop.size,
200)
parameters.CSMC.AS.repM$lambda[1,r] <- mh.lambda.update$new.lambda
accept.lambda <- c(accept.lambda, mh.lambda.update$indicator)
# parameters.CSMC.AS.repM$lambda[1,r] <- 2000
# # p
# mh.p.update <- update.p(y,
#                         RefParticleX,
#                         RefParticleS, RefParticleE, RefParticleI, RefParticleR,
#                         parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
#                         parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
#                         parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
#                         parameters.CSMC.AS.repM$kappa[1, r], a.kappa, b.kappa,
#                         parameters.CSMC.AS.repM$lambda[1, r], a.lambda, b.lambda,
#                         parameters.CSMC.AS.repM$p[1, r - 1], a.p, b.p,
#                         parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
#                         parameters.CSMC.AS.repM$f[, r - 1], a.f, b.f,
#                         pop.size,
#                         0.01)
# parameters.CSMC.AS.repM$p[1, r] <- mh.p.update$new.p
# accept.p <- c(accept.p, mh.p.update$indicator)
parameters.CSMC.AS.repM$p[1, r] <- 0.25
# pi.k in Px
mh.pi.k.update <- update.pi.k(y,
RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r - 1]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1], a.f, b.f,
pop.size,
0.05)
parameters.CSMC.AS.repM$Px[[r]]<- mh.pi.k.update$newPx
# accept.Px[mh.pi.k.update$k,r-1] <-  mh.pi.k.update$indicator
if (mh.pi.k.update$k == 1){
accept.pi.1 <- c(accept.pi.1, mh.pi.k.update$indicator)
}else if (mh.pi.k.update$k == 2){
accept.pi.2 <- c(accept.pi.2, mh.pi.k.update$indicator)
}
# f_{x_t}: f1=1, f2~MH step
mh.f.update  <- update.f(y, RefParticleX,
RefParticleS, RefParticleE, RefParticleI, RefParticleR,
parameters.CSMC.AS.repM$alpha[1, r], m.alpha, sigma.alpha,
parameters.CSMC.AS.repM$beta[1, r], m.beta, sigma.beta,
parameters.CSMC.AS.repM$gamma[1, r], m.gamma, sigma.gamma,
parameters.CSMC.AS.repM$kappa[1, r], a.kappa, b.kappa,
parameters.CSMC.AS.repM$lambda[1, r], a.lambda, b.lambda,
parameters.CSMC.AS.repM$p[1, r], a.p, b.p,
parameters.CSMC.AS.repM$Px[[r]], delta.mat,
parameters.CSMC.AS.repM$f[, r - 1], a.f, b.f,
pop.size,
0.05)
parameters.CSMC.AS.repM$f[,r] <- mh.f.update$new.f
accept.f[,r-1] <-  mh.f.update$indicator
setTxtProgressBar(pb, r)
}
par(mfrow=c(4,2))
plot(parameters.CSMC.AS.repM$alpha[1, ], type="l", xlab="Iterations", ylab = expression(alpha), panel.first=abline(h = alpha, col = "red"))
plot(parameters.CSMC.AS.repM$beta[1, ], type="l", xlab="Iterations", ylab = expression(beta), panel.first=abline(h = beta, col = "red"))
plot(parameters.CSMC.AS.repM$gamma[1, ], type="l", xlab="Iterations", ylab = expression(gamma), panel.first=abline(h = gamma, col = "red"))
plot(parameters.CSMC.AS.repM$kappa[1,1:10], type="l", xlab="Iterations", ylab = expression(kappa), panel.first=abline(h = kappa, col = "red"))
plot(parameters.CSMC.AS.repM$lambda[1, ], type="l", xlab="Iterations", ylab = expression(lambda), panel.first=abline(h = lambda, col = "red"))
# plot(parameters.CSMC.AS.repM$p[1, ], type="l", xlab="Iterations", ylab = expression(p), panel.first=abline(h = p, col = "red"))
# plot(parameters.CSMC.AS.repM$f[1, ], type="l", xlab="Iterations", ylab = expression(f[1]), panel.first=abline(h = f[1,1], col = "red"))
plot(parameters.CSMC.AS.repM$f[2, ], type="l", xlab="Iterations", ylab = expression(f[2]), panel.first=abline(h = f[2,1], col = "red"))
